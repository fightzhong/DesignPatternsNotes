## 代理模式
### 引入(让别人帮自己做自己不想做的事情)
```
引入一个场景, 我们要求在对数据库进行操作时, 比如insert, 在操作的前后要进行日志的输出, 以便后期的
统计, 真正操作数据库是在dao层, 所以我们就会有以下代码
```
- Dao层接口
  ```java
  public interface IDao {
    /**
    * 向数据库中添加数据
    * @return
    */
    public int insert ();
  }
  ```
- Dao层实现
  ```java
  public class DaoImpl implements  IDao {
    @Override
    public int insert () {
      System.out.println( "操作数据库开始" );

      // 这里使用伪代码, 假设往数据库里插入了数据
      System.out.println( "正在操作数据库, 操作成功后返回影响条数为1" );

      System.out.println( "操作数据库结束" );
      return 1;
    }
  }
  ```
- 调用时的代码(Service层调用)
  ```java
  Dao dao = new Dao();
  dao.insert();
  ```  
### 分析
```
根据上面的代码, 我们发现打印日志的代码也会被写入到insert方法中, 按照分层结构,dao层只处理对数据库
的操作, 不进行任何的业务操作, 那么这个打印日志的操作是不应该出现在这里的, 这时我们引入静态代理来
处理, 静态代理主要做的事就是去对日志的输出,而dao层只实现其自身的功能, 如下
```
- dao层的代码改进
  ```java
  public class DaoImpl implements  IDao {
    @Override
    public int insert () {
      // 这里使用伪代码, 假设往数据库里插入了数据
      System.out.println( "正在操作数据库, 操作成功后返回影响条数为1" );
      return 1;
    }
  }
  ```
- 引入静态代理来进行日志输出
  ```java
  public class DaoProxy implements IDao {
    private DaoImpl dao;

    public DaoProxy (DaoImpl dao) {
      this.dao = dao;
    }

    @Override
    public int insert () {
      System.out.println( "操作数据库开始" );
      int result = dao.insert();
      System.out.println( "操作数据库结束" );
      return result;
    }
  }
  ```
- 调用时的代码(Service层调用)
  ```java
  DaoProxy proxy = new DaoProxy( new DaoImpl() );
  proxy.insert();
  ```
### 分析
```
<1> dao层实现其本身的功能, 即对数据库的操作, 没有其它的代码
<2> 静态代理实现了IDao接口, 因为以后Service层就不再直接调用dao层的代码了, 而是通过这个静态代理来
    调用DaoProxy, 所以Daoproxy需要实现这个接口, 并实现重写insert方法
<3> 在这个重写的insert方法中, 加入日志操作, 而真正操作数据库的任务仍然需要由dao层来处理, 所以我们
    通过构造器注入的方式来将这个DaoImpl注入   
```

### 问题分析
```
在上面的静态代理中, 我们需要为IDao接口实现一个静态代理类, 我们发现, 我们仅仅代理了一个insert方法,
那么加入dao层有20个方法, 每个方法都要对其进行日志输出呢?那么我们的静态代理就需要重写20个方法, 然后
对每个方法进行日志输出, 更加可怕的是, 假如我们需要代理20个类, 每个类的所有方法都要日志输出呢?那么
就要写出20个代理类, 每个代理类都重写20个方法, 这样就会使得性能受到影响了, 所以这时我们就要引入动态
代理
```

### 动态代理引入
```
实现动态代理需要两个东西, 一个是处理器, 一个是代理的对象(如DaoImpl实例dao), 处理器是用来对dao的
所有方法进行处理的, 假设dao的所有方法都要进行日志输出, 那么我们的处理器完成的功能就是对日志的操作, 
同时引入dao这个对象在处理器中负责数据库本身的操作, 有了这两个东西后, 我们就可以用JDK提供的ProxyAPI
来构建动态代理对象, 这样可能比较抽象, 下面我们用代码来告知=,=
```

- dao层类接口
  ```java
  public interface IDao {
    /**
    * 插入数据到数据库
    * @return
    */
    public int insert ();
  }
  ```
- dao层的实现类
  ```java
  public class DaoImpl implements IDao{

    @Override
    public int insert () {
      System.out.println( "正在操作数据库, 操作成功后返回影响条数为1" );
      return 1;
    }
  }
  ```
- 动态代理的具体实现
  ```java
  // 创建一个Dao实现类, 可以是DaoImpl也可以是IDao类型
  DaoImpl dao = new DaoImpl();

  /*
   * 接下来要对这个dao对象进行动态代理, 即对这个对象进行增强, 动态代理是生成一个新的类, 那么我们就
   * 需要考虑这个类是什么类型的呢? 通过Proxy.newProxyInstance来生成一个动态代理类对象, 这时需要
   * 三个参数, 一个是我们需要增强的对象对应的类加载器, 一个是该对象实现的所有接口, 一个
   * InvocationHandler接口实现类, 由于该接口是一个函数式接口, 所以可以用lamada表达式来实现对应的
   * invoke方法
   * 动态代理的实现原理简单描述:
   *    通过需要被增强的对象dao实现的接口来创建一个动态代理类对象Proxy$0, 该类对象实现了所有dao对象
   *    实现的接口, 所以说动态代理类不是dao类对象, 而是其接口的实现类
   */
  IDao proxyDao = Proxy.newProxyInstance( dao.getClass().getClassLoader(),
      dao.getClass().getInterfaces, ( proxy, method, args ) -> {
      /**
       * invoke方法：
       *    proxy: 生成的动态代理类实例
       *    method: 包含了dao所有接口的方法, 而不是DaoImpl本身实现的方法
       *    args: 调用这些方法时的参数
       *    当我们通过动态代理类对象(假设是proxyObj)调用insert方法(IDao接口的方法)时, 如下所示,
       *    会通过method.invoke(dao, args)来调用dao的insert方法, 返回值是调用该方法的返回值, 总
       *    的来说, 调用dao实现的接口的所有方法, 都会被代理成这个InvocationHandler的invoke方法,
       *    即当前这个方法, 那么为了使得调用后实现DaoImpl实现类中insert方法的功能, 我们需要在invoke
       *    方法中调用method.invoke( dao, args )来通过反射的方式实现调用dao的insert方法
       */
       System.out.println( "start..." );
       Object result = method.invoke( dao, args );
       System.out.println( "end..." );
       return result;
  } )

  ```
### Java动态代理深层分析
```
<1> 对于Proxy.newProxyInstance这个方法来说, 其返回的对象是com.sun.proxy.$Proxy0类对象, 但是这个
    类对我们而言是不可见的, 而Proxy类在动态生成这个代理类的时候提供了一个方式, 可以使得我们能够将
    这个$Proxy0类以文件的形式保存下来, 在ProxyGenerator类中存在一个判断, 如果saveGeneratedFiles
    为true, 则将该代理类保存为文件, 而saveGeneratedFiles变量指向一个系统属性, 所以我们可以通过增
    加该系统属性来获取代理类文件: 
    System.getProperties().put(  "sun.misc.ProxyGenerator.saveGeneratedFiles", "true"  );
<2> 通过分析这个代理类的代码(由idea反编译得到), 我们可以发现在真正调用类方法的时候都会转为调用
    InvocationHandler的invoke方法, 并将this(代理类对象本身), Method, args作为参数传递, Method
    则是在该代理类被使用时通过静态代码块初始化的, 包含了原类的方法, 静态代码块中通过反射的方式获取
    这些方法
<3> 我们在Proxy.newProxyInstance方法中传递的类加载器是用来加载这个代理类的, 类实现的接口数组是为
    用于在生成代理类时实现原来的类的接口, 以及InvocationHandler对象是用来在调用方法时转为该对象去
    执行方法, 代理类的动态创建同样也需要字节数组, 然后利用Proxy中defineClass0(native)方法来生成
    代理类的Class对象
<4> 代理类的创建主要用Proxy中的内部类对象ProxyClassFactory来创建
<5> 除了原来的类的方法被代理之外, Object类中的hashcode, equals, toString方法也会被代理类代理, 即
    在代理类$Proxy0中会增加这三个方法的调用, 然后转为invoke调用
```  

### 总结
```
定义: 为其它对象提供一种代理, 以控制对这个对象的访问
      代理对象在客户端和目标对象之间起到中介的作用

优点:
    <1> 代理模式能将代理对象与真实被调用的目标对象分离
    <2> 一定程度上降低了系统的耦合度, 扩展性好
    <3> 保护目标对象  
    <4> 增强目标对象

缺点:
    <1> 代理模式会造成系统设计中类的数目增加
    <2> 在客户端和目标对象增加一个代理对象, 会造成请求处理速度变慢
    <3> 增加系统的复杂度
```

### 扩展CGLib代理(后期再回来补充)
```
实现原理: 通过继承类来代理类, 即获得子类从而重写方法, 要考虑类, 方法是否被final修饰
```
